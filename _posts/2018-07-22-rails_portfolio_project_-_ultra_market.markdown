---
layout: post
title:      "Rails Portfolio Project - Ultra Market"
date:       2018-07-23 03:59:13 +0000
permalink:  rails_portfolio_project_-_ultra_market
---


Wow...so I just want to start off by saying that the Rails curriculum is intense. There is so much information that you get exposed to that it makes starting the final project seem kinda daunting at first. However, I am proud to say that I have finished my project (the MVP, anyway). It took a lot of time and effort to get everything working properly, but it was so worth it. Let's dive into how this process unfolded.

So first, I had to come up with my idea for the project. I decided on making an online marketplace because it would allow for more than just the minimum requirements for the models. Defining your models is usually the best place to start with any rails app. I was unsure of how exactly to differentiate users as "merchants" and "clients" until I got solid advice from Luisa's Rails Project Prep study group. It would be wise, she said, to make each user account belong to one merchant and/or one client while letting the Merchant and Client models do all the heavy lifting. What this essentially boils down to is that a UserAccount belongs_to a Merchant and belongs_to a Client. But what if someone doesn't want to sell anything and just wants to buy things? That's where belongs_to :model, :optional => true comes in. This allows a model that normally has a mandatory belongs_to relationship to allow for optional relationships. This was perfect for my project as it would allow users to choose whether they wanted to buy, sell, or do both!

The next part was defining the rest of my models. Merchants have many items and many services. Clients have many items and many services. This means that Item and Service are both join tables for Merchant and Client. This allows merchants to have many clients through items, and vice versa. Same thing goes for services. An item or service that originally belonged to a merchant (after he/she posts the item/service for sale) would then also belong to a client (after he/she buys that item/service). Items and services have optional belongs_to relationships with merchants and clients - this allows for items to remain not bought without throwing some kind of nil error.

The next step was to start defining my routes, controller actions, and views. I did the standard RESTful routes using resources for all my models. I had to define special routes for loggin in and out - that's where the sessions controller comes in handy. Going back and forth between routes, controllers, and views does get a bit frustrating when there's so much functionality you have to implement. It's even more difficult when you have to separate out functionality between merchants and clients on every page! Fortunately, I defined helper methods for items and services to account for client_view and merchant_view. These allowed for only clients to see a "buy this item/service" link and for only merchants to see "edit this item/service" and "delete this item/service". I also had to make my "buy this item/service" functionality work. For this, I had to define my own routes for buying an item and buying a service. I ended up doing the following: post "/items/:id" => "items#buy" and post "/services/:id" => "services#buy". Running rake routes let me see that this combination of method and action was not already being used by the standard RESTful convention. So I defined these routes and controller actions, and I was glad to see that upon clicking the buy link, it successfully redirected to the client_items_path or client_services_path. Finally, I guess another good lesson that comes from all of this is to make sure you define your routes in the order you want them to run. I had class methods for items and services to allow filtering by date - self.most_recent and self.oldest. To make the routes for these work, I had to define them before the standard RESTful routes for items and services. Otherwise, get "/items/:id" would run before get "items/most_recent" and we all know that an id shouldn't equal "most_recent"!

So yeah, it's been a long and bumpy ride learning the beauty and magic of Rails. I'm sure there's a lot more I can do to improve the functionality of my Ultra Market app, but for now, I am proud of what I have accomplished so far. Stay tuned for more updates as I dive into the world of Javascript next!
